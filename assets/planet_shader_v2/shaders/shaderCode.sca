// Based on code by viclw17
// https://www.shadertoy.com/view/XsVBWG
// Rewritten to Spark SL with a few tweaks and random parameters.


namespace fb {
     vec3 makeJupiter(vec2 uv, float blueFloat, float greenFloat, float redFloat, float randMovmntX, float randMovmntY, float scaleX, float scaleY)
		{
    float iTime = std::getTime();
  //speed
	// float timeScale = .5;
 //  	float timeScaleTwo = .2;
 	float timeScale = scaleX;
  	float timeScaleTwo = scaleY;
  
	vec2 zoom = vec2(20.,5.5);
	vec2 offset = vec2(2., 1.);

    
    vec2 point = uv * zoom + offset;
    float p_x = float(point.x); 
    float p_y = float(point.y);
    
  //movement
    float a_x = randMovmntX; 
    float a_y = randMovmntY;
    
    for(int i=1; i<int(10); i++){
        float float_i = float(i); 
        point.x+=a_x*sin(float_i*point.y+iTime*timeScale);
        point.y+=a_y*cos(float_i*point.x+iTime*timeScaleTwo);
    }
    
  //colors
    float r = cos(point.x+point.y+redFloat)*.5+.5;
    float g = sin(point.x+point.y+greenFloat)*.5+.5;
    float b = (sin(point.x+point.y+blueFloat)+cos(point.x+point.y+blueFloat))*.5+.5;
    
    vec3 col = vec3(r,g,b);
    col += vec3(.3);

    return col;
	}
 }
// Entry point of the shader code asset

//
// @param[default=5.0,min=0.1,max=9.9] blueFloat
// @param[default=5.0,min=0.1,max=9.9] greenFloat
// @param[default=5.0,min=0.1,max=9.9] redFloat
// @param[default=0.2,min=0.1,max=0.3] randMovmntX
// @param[default=0.3,min=0.1,max=0.3] randMovmntY
// @param[default=0.2,min=0.2,max=0.9] scaleX
// @param[default=0.3,min=0.2,max=0.9] scaleY
// @return color
vec4 main(float blueFloat, float greenFloat, float redFloat, float randMovmntX, float randMovmntY, float scaleX, float scaleY) {
  
  float time = std::getTime();
  vec2 iResolution = normalize(std::getRenderTargetSize());
  vec2 texCoord = fragment(std::getVertexTexCoord());
  texCoord = vec2(texCoord.y,texCoord.x);
  vec2 iPosition = fragment(std::getVertexTexCoord());
  vec2 position = fragment(std::getVertexTexCoord());
  //form of planet
  vec2 center = iResolution.xy / 2.;
  center += vec2(0.25, 0.075);
  float dis = distance(center, position.xy);
  float radius = iResolution.y / 3.;
  vec3 atmosphereColor = vec3(.7, .6, .5);
  vec4 color;
    // inside planet
  if (dis < radius) {
		// Find planet coordinates
		vec2 posOnPlanet = (position - (center - radius));
		vec2 planetCoord = posOnPlanet / (radius * 2.0);
		
		// Spherify it
		planetCoord = planetCoord * 2.0 - 1.0;
		float sphereDis = length(planetCoord);
		sphereDis = 1.0 - pow(1.0 - sphereDis, .6);
		planetCoord = normalize(planetCoord) * sphereDis;
		planetCoord = (planetCoord +1.) / 2.0;
		
		// Calculate light amounts
		float light = pow(planetCoord.x, 1.5*0.7);
		float lightAtmosphere = pow(planetCoord.x*0.05, 0.5);
		
		// Apply light
		vec3 surfaceColor = fb::makeJupiter(planetCoord, blueFloat, greenFloat, redFloat, randMovmntX, randMovmntY, scaleX, scaleY);
		surfaceColor *= light;
		
		// Atmosphere
		float fresnelIntensity = pow(dis / radius, 3.);
		vec3 fresnel = mix(surfaceColor, atmosphereColor, fresnelIntensity * lightAtmosphere);
		
		color = vec4(fresnel.rgb, 1.0);
        color *= texCoord.x * 2.5;
    	return vec4(color.rgb, 1.0);
	} else {
		vec3 background = vec3(0, 0, 0);
		// Atmosphere on top
		float outter = distance(center, position) / iResolution.y;
		outter = 1.0 - outter;
		outter = clamp(outter, 0.5, 0.8);
		outter = (outter - .5) / .3;
		outter = pow(outter, 2.8);
		
		// Add atmosphere on top
		color = vec4(background + atmosphereColor * outter, 1);
		return vec4(color.rgb, outter);
	}
}

